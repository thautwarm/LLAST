import std.common.[Space Name]
[python] import proc.[*]
ignore [Space]
num := R'0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)'


to_const cast :=
    'type' 'fn' '->' '[|' '|]' 'return' 'if' 'else' 'let' '>=' '<=' '==' '>>' '<<' 'or' 'and' 'not' 'xor'

defun ::= 'fn' Name '(' arg* ')' ':' ty '->' suite
defty ::= 'type' Name '=' ty

arg  ::= Name ':' ty

ty   ::=
    (Name
    |'{' (ty to [agg])+ '}'
    | ty '['  num as vec ']'
    | ty '[|' num as arr '|]') ['*' as ptr]

stmt  ::= ['return'] expr| defty | defun

suite ::= '{' stmt+ '}'

expr ::=
    | '*' as PTR expr
    |  expr '(' expr* ')' as CALL
    |  expr '.' num as ATTR
    |  expr '.' '[' expr ']' as INDEX
    | 'if' as IF expr as cond
        suite as iftrue
      'else'
         suite as iffalse
    | 'let' as LET
         Name as name '=' expr as expr
       suite as suite
    | or as OR
    rewrite
        if OR:
            return proc_to_str(OR)
        else:
            raise NotImplemented



or  ::= and as it ('or' and to [tail])*
        rewrite
            if not tail:
                return it
            for each in tail:
                it = concat(Ordered(f"Bin("), "Or", ',', it, ',', each, ')')
            it


and ::= not as it ('and' not to [tail])*
        rewrite
            if not tail:
                return it
            for each in tail:
                it = concat(Ordered(f"Bin("), "And", ',', it, ',', each, ')')
            it

not ::= ['not' as ab] cmp as it
        rewrite
            if ab:
                return concat(Ordered(f"Bin("), "XOr", ',', it, ',', "Const <| ID(8, 1L)", ')')
            return it

cmp_ ::= ('>=' | '<=' | '>' | '<' | '==') as op shl as it
        rewrite op, it
cmp ::= shl as it cmp_* as tail
        rewrite
            if not tail:
                return it
            for op, each in tail:
                v = op.value
                inst = 'Ge' if v == '>=' else\
                       'Le' if v == '<=' else\
                       'Gt' if v == '>'  else\
                       'Lt' if v == '<'  else\
                       'Eq'
                it = concat(Ordered(f"Bin("), inst, ',', it, ',', each, ')')
            return it

shl_ ::= ('>>' | '<<' | 'xor' | '&') as op add as it
         rewrite op, it
shl ::= add as it shl_* as tail
        rewrite
            if not tail:
                return it
            for op, each in tail:
                v = op.value
                inst = 'LShr' if v == '>>' else\
                       'LSh' if v == '<<' else\
                       'XOr' if v == 'xor'  else\
                       'And'
                it = concat(Ordered(f"Bin("), inst, ',', it, ',', each, ')')
            return it


add_ ::= ('+' | '-') as op mul as it
         rewrite op, it

add ::= mul as it add_* as tail
        rewrite
            if not tail:
                return it
            for op, each in tail:
                if op.value == '+':
                    it = concat(Ordered(f"Bin("), 'Add,', it, ',', each, ')')
                else:
                    it = concat(Ordered(f"Bin("), 'Sub', ',', it, ',', each, ')')
            return it


mul_ ::= ('*'| '/'| '%') as op pow as pow
         rewrite op, pow

mul ::= pow as it mul_* as tail
        rewrite
            if not tail:
                return it
            for op, each in tail:
                if op.value == '*':
                    it = concat(Ordered(f"Bin("), 'Mul', ',', it, ',', each, ')')
                elif op.value == '/':
                    it = concat(Ordered(f"Bin("), 'Div', ',', it, ',', each, ')')
                else:
                    it = concat(Ordered(f"Bin("), 'Rem', ',', it, ',', each, ')')
            it

pow ::= ato as ato ['^' pow as pow]
        rewrite
            if pow:
                it = concat(Ordered(f"Bin("), 'Pow', ',', it, ',', each, ')')
            ato


ato ::= num as num ':' num as bit| Name as name | '(' expr as expr ')'
        rewrite
            if num:
                bit = eval(bit.value)
                value = eval(num.value)
                if isinstance(value, int):
                    return Ordered(f"Const <| ID({bit}, {value}L)")
                else:
                    return Ordered(f"Const <| FD({bit}, {value}L)")
            elif name:
                return Ordered(f'Get("{name.value}")')
            expr



stmts ::= stmt+

